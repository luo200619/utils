<?php
 namespace szj\utils;  Class Map { Private $apiUrl = [ 'address'=>'http://api.map.baidu.com/geocoder/v2/?address=%s&output=json&ak=%s&city=%s', 'distance'=>'http://api.map.baidu.com/routematrix/v2/walking?output=json&ak=%s&origins=%s&destinations=%s', 'unaddress'=>'http://api.map.baidu.com/geocoder/v2/?location=%s&output=json&pois=1&latest_admin=1&ak=%s' ];  Private $config = [ 'ak'=>'' ];  Private $error = [ 0=>'地址解析成功', 1=>'服务器内部错误', 2=>'请求参数非法', 3=>'权限校验失败', 4=>'今日已经用完免费额度的调用次数', 5=>'接口ak值不存在或者非法', 101=>'当前服务被禁用', 102=>'不通过白名单或者安全码不对', 999=>'网络请求失败,请联系管理员', 998=>'系统出错了,请联系管理员', ];  Public function __construct($config = []){ $this->config = array_merge($this->config,$config); }  Public function GetLngLat($address,$city = '',$ak = ''){ if(!empty($ak)) $this->config['ak'] = $ak; $apiurl = sprintf($this->apiUrl['address'],$address,$this->config['ak'],$city); try{ $res = curl_get($apiurl); $data = json_decode($res,true); if(empty($data)){ $result = appResult($this->error[998]); } else { $status = $data['status']; if(empty($status)){ $result = appResult($this->error[$status],$this->HanadleLngLat($data),false); } else { if(isset($this->error[$status])) $result = appResult($this->error[$status]); else $result = appResult('无调用权限或超出调用次数'); } } } catch(\Exception $err){ $result = appResult($err->getMessage()); } return $result; }  Public function getCoordinate($address = '',$city = '',$ak = ''){ if(!empty($ak)) $this->config['ak'] = $ak; $apiurl = sprintf($this->apiUrl['address'],$address,$this->config['ak'],$city); try{ $res = curl_get($apiurl); $data = json_decode($res,true); if(empty($data)){ $result = appResult($this->error[998]); } else { $status = $data['status']; if(empty($status)){ $result = appResult($this->error[$status],$this->HanadleLngLat($data),false); } else { if(isset($this->error[$status])) $result = appResult($this->error[$status]); else $result = appResult('无调用权限或超出调用次数'); } } } catch(\Exception $err){ $result = appResult($this->error[999]); } return $result; }  Public function getAddress($lat = '',$lng = '',$ak = '',$all = false,$options = []){ if(!empty($ak)) $this->config['ak'] = $ak; try{ $url = sprintf($this->apiUrl['unaddress'],$lat.','.$lng,$this->config['ak']); $res = json_decode(curl_get($url),true); if(empty($res)){ $result = appResult('解析错误'); } else { if(empty($result['status'])){ $result = appResult('SUCCESS',$all?$res['result']:$res['result']['formatted_address'],false); } else { $result = appResult($this->error[$result['status']]); } } } catch(\Exception $err){ $result = appResult($err->getMessage()); } return $result; }  Private function HanadleLngLat(&$data = []){ $tmp = []; if(isset($data['result']['location'])){ $tmp = $data['result']['location']; $comprehension = intval($data['result']['comprehension']); if($comprehension == 100){ $tmp['reliability'] = 0.91; } elseif($comprehension >= 90){ $tmp['reliability'] = 0.89; } elseif($comprehension >= 80){ $tmp['reliability'] = 0.88; } elseif($comprehension >= 70){ $tmp['reliability'] = 0.84; } elseif($comprehension >= 60){ $tmp['reliability'] = 0.81; } elseif($comprehension >= 50){ $tmp['reliability'] = 0.79; } else { $tmp['reliability'] = 0; } } return $tmp; }  Public function IsPoint($point, $pts) { $N = count($pts); $boundOrVertex = true;  $intersectCount = 0;  $precision = 2e-10;  $p1 = 0;  $p2 = 0; $p = $point;  $p1 = $pts[0];  for ($i = 1; $i <= $N; ++$i) {  if ($p['lng'] == $p1['lng'] && $p['lat'] == $p1['lat']) { return $boundOrVertex; } $p2 = $pts[$i % $N]; if ($p['lat'] < min($p1['lat'], $p2['lat']) || $p['lat'] > max($p1['lat'], $p2['lat'])) { $p1 = $p2; continue; } if ($p['lat'] > min($p1['lat'], $p2['lat']) && $p['lat'] < max($p1['lat'], $p2['lat'])) { if($p['lng'] <= max($p1['lng'], $p2['lng'])){ if ($p1['lat'] == $p2['lat'] && $p['lng'] >= min($p1['lng'], $p2['lng'])) { return $boundOrVertex; } if ($p1['lng'] == $p2['lng']) { if ($p1['lng'] == $p['lng']) { return $boundOrVertex; } else { ++$intersectCount; } } else { $xinters = ($p['lat'] - $p1['lat']) * ($p2['lng'] - $p1['lng']) / ($p2['lat'] - $p1['lat']) + $p1['lng']; if (abs($p['lng'] - $xinters) < $precision) { return $boundOrVertex; } if ($p['lng'] < $xinters) { ++$intersectCount; } } } } else { if ($p['lat'] == $p2['lat'] && $p['lng'] <= $p2['lng']) { $p3 = $pts[($i+1) % $N]; if ($p['lat'] >= min($p1['lat'], $p3['lat']) && $p['lat'] <= max($p1['lat'], $p3['lat'])) { ++$intersectCount; } else { $intersectCount += 2; } } } $p1 = $p2; } return !($intersectCount % 2 == 0); }  Public function Distance($org,$dest,$ak = ''){ if(!empty($ak)) $this->config['ak'] = $ak; $orgstr = '';$deststr = ''; if(is_array($org)) $orgstr = implode('|', $org); else $orgstr = $org; if(is_array($dest)) $deststr = implode('|',$dest); else $deststr = $dest; $apiurl = sprintf($this->apiUrl['distance'],$this->config['ak'],$orgstr,$deststr); try{ $res = curl_get($apiurl); $data = json_decode($res,true); if(empty($data)){ $result = appResult($this->error[998]); } else { $status = intval($data['status']); if(!empty($status)){ if(isset($this->error[$status])) $result = appResult($this->error[$status]); else $result = appResult('无调用权限或超出调用次数'); } else { $result = appResult($this->error[$status],$this->HanadleDistance($data,$orgstr,$deststr),false); } } } catch(\Exception $err){ $result = appResult($this->error[999]); } return $result; }  Private function HanadleDistance(&$data = [],&$orgstr,&$deststr){ $orgarr = explode('|', $orgstr); $destarr = explode('|',$deststr); $result = []; $tmpData = []; $callback = function($val,$key) use(&$tmpData){ if(isset($val['distance'])) $tmpData[$key] = $val['distance']['value']; else $tmpData[$key] = -1; }; if(isset($data['result']) && !empty($data['result'])){ array_walk($data['result'],$callback); if(count($orgarr) > 1){ $result = array_chunk($tmpData, count($destarr)); } else { $result = $tmpData; } } return $result; } }